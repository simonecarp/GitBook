Ethereum: Libro Giallo - Yellow Paper
(una traduzione di Simone Carpentieri: s.carpentieri@gmail.com)

# Ethereum ‚Äì un registro di transazioni decentralizzato generalizzato sicuro

Abstract. Il paradigma della blockchain, quando innestato a transazioni crittograficamente sicure ha dimostrato la sua utilit√† in numerosi progetti, non ultima Bitcoin. Tali progetti possono essere visualizzati come una semplice applicazione all‚Äôinterno di una risorsa digitale decentralizzata ma unica. Tale paradigma pu√≤ essere definito come macchina transazionale unica a stato condiviso.
Ethereum implementa questo paradigma in maniera generalizzata. Inoltre, fornisce una pluralit√† di risorse simili, ognuna delle quali con uno stato ed un codice operativo distinto ma capace di interagire attraverso una struttura di trasmissione di messaggi con ognuna delle altre risorse. Discutiamo qui il suo sviluppo, i problemi di implementazione, le opportunit√† che fornisce ed alcuni possibili ostacoli futuri.


##I.	Introduzione
La disponibilit√† massiccia di connessioni internet nella maggior parte del pianeta ha permesso alla trasmissione globale di informazioni di diventare incredibilmente conveniente. Le iniziative radicate nella tecnologia ‚Äì come Bitcoin ‚Äì hanno dimostrato, attraverso la potenza di meccanismi del consenso e del rispetto volontario del contratto sociale, che √® possibile utilizzare la rete per creare un sistema di trasferimento di valore decentralizzato, condiviso liberamente in tutto il mondo e virtualmente gratuito. 
Tale sistema pu√≤ considerarsi una versione molto specializzata di un meccanismo crittografico sicuro, basato sulle transazioni. Sistemi successivi quali Namecoin hanno adottato questa ‚Äúapplicazione valutaria‚Äù della tecnologia all‚Äôinterno di altre applicazioni, sebbene alquanto semplici.
Ethereum costituisce un progetto che tenta di costruire la versione generalizzata di tale tecnologia; ossia una tecnologia su cui qualsiasi idea, applicata al meccanismo basato sulle transazioni di stato, possa essere sviluppata. Inoltre esso mira a fornire allo sviluppatore un sistema end-to-end strettamente integrato per la creazione di software secondo un paradigma di computazione fino ad ora sconosciuto alla maggioranza: un sistema di computazione object messaging affidabile.


###I.I Fattori Chiave. 
Gli obiettivi di questo progetto sono molteplici; un obiettivo chiave √® di facilitare le transazioni tra individui consenzienti che non avrebbero altrimenti mezzi per garantire reciproca fiducia. Ci√≤ potrebbe essere dovuto alla distanza geografica, a difficolt√† di interfacciamento, o ad incompatibilit√†, incompetenza, indisponibilit√†, spese, incertezza, non convenienza o difetto dei sistemi legali esistenti. Nel momento in cui sar√† specificato un sistema di cambiamento di stato attraverso un linguaggio di sviluppo ricco e privo di ambiguit√†, e predisposta una architettura con caratteristiche tali che sia ragionevole attendersi che un accordo tra due parti sar√† di per s√© in grado di costringere le parti a rispettarne i termini, tutti gli strumenti utili allo scopo saranno disponibili.
Gli accordi nel sistema proposto avrebbero diverse caratteristiche non necessariamente presenti nel mondo reale. Ad esempio, l‚Äôincorruttibilit√† di giudizio, spesso difficile da trovare, sarebbe naturalmente ottenuta tramite un interprete algoritmico. La trasparenza, ossia la possibilit√† di constatare esattamente, attraverso il transaction log, le regole o il codice informativo, le modalit√† con cui uno stato o un giudizio siano pervenuti, non √® riscontrata mai nelle societ√† umane, dal momento che il linguaggio naturale √® per sua natura vago, le informazioni sono spesso incomplete ed i pregiudizi sono difficili da eliminare.
In complesso, desidero fornire un sistema tale che gli utenti possano essere sicuri del risultato finale, a prescindere dal soggetto, sistema od organizzazione con cui interagiscono, e di come a tale risultato si sia pervenuti.


###I.II Lavori precedenti. 
Fu Buterin [2013] a proporre per primo i concetti fondamentali del presente lavoro, nel tardo novembre del 2013. Nonostante questo si sia evoluto in molteplici maniere, il concetto chiave della blockchain, accompagnata da un linguaggio Turing-completo ed uno spazio di archiviazione inter-transazione praticamente illimitato, rimane immutata. Il sistema Hashcash introdotto da Back [2002] (in una retrospettiva quinquennale), costitu√¨ il primo impianto per l‚Äôimpiego di un sistema che richiedesse una prova dell‚Äôimpiego di risorse computazionali tramite decifrazione crittografica (proof of work), quale mezzo per la trasmissione di un segnale di valore in Internet. Nonostante esso non fu mai adottato su ampia scala, il lavoro fu poi riciclato ed espanso da Nakamoto [2008] per concepire un meccanismo crittograficamente sicuro per approdare ad un consenso generalizzato decentralizzato sull‚Äôordine ed il contenuto di una serie di transazioni finanziarie a firma digitale crittografica. Dai frutti di questo progetto, Bitcoin, √® derivata una prima impressione di un registro di transazioni decentralizzato.
Altri progetti furono poi costruiti sul successo di Bitcoin; le alt-coins introdussero numerose altre valute attraverso l‚Äôalterazione del protocollo. Alcune delle pi√π famose sono Litecoin e Primecoin, discusse da Sprankel [2013]. Altri progetti hanno puntato a sfruttare il meccanismo dietro ai core values del protocollo e riproporli; Aron [2012] discute, ad esempio, il progetto Namecoin che mira a creare un sistema di name-resolution decentralizzato. 
Le funzioni che operano su valori altamente strutturati sono denotate con una lettera greca maiuscola, come ad esempio la funzione di transizione di stato œí.
Per la maggior parte delle funzioni, viene utilizzata una lettera maiuscola, ad es. C, la funzione generale di costo. Eventuali pedici denoteranno varianti specializzate, ad es. CSSTORE, la funzione di costo legata all‚Äôoperazione SSTORE. Per funzioni specifiche, eventualmente definite esternamente, la formattazione del testo assume un effetto ‚Äúmacchina da scrivere‚Äù, ad esempio la hash function Keccak-256 (codifica vincente della competizione SHA-3) √® denotata come KEC (e generalmente segnalata semplicemente come Keccak).
Alle tuple [http://it.wikipedia.org/wiki/Tupla] ci si riferisce tipicamente con lettere maiuscole, ad esempio T, che √® utilizzata per denotare una transazione Ethereum. Quando specificato, per componenti individuali, possono essere aggiunti pedici, come Tn, indicante l‚Äôattributo nonce [http://it.wikipedia.org/wiki/Nonce] della suddetta transazione. La forma pedice, a sua volta, viene utilizzata per denotare il tipo; ad esempio, pedici in lettera maiuscola si riferiscono a tuple con attributi subscriptable [http://stackoverflow.com/questions/216972/in-python-what-does-it-mean-if-an-object-is-subscriptable-or-not].
Le sequenze scalari e a dimensione fissa (anche dette array o vettori), sono denotate con lettere dell‚Äôalfabeto minuscole, ad esempio n viene utilizzata per riferirsi alla transazione nonce. Per gli array con significati speciali, utilizzeremo le greche, ad es. Œ¥, che √® il numero di oggetti richiesti dallo stack [http://it.wikipedia.org/wiki/Stack] per una data operazione.
Sequenze arbitrariamente lunghe sono tipicamente denotate con una lettera minuscola in grassetto, ad es. o verr√† utilizzata per la sequenza di byte restituita come output di un messaggio di chiamata. Per valori particolarmente importanti, la lettera sar√† maiuscola.
Nel presente lavoro, si assume che gli scalari siano interi positivi e quindi che appartengano all‚Äôinsieme ‚Ñô. L‚Äôinsieme di tutte le sequenze di byte √® ùîπ, formalmente definita nell‚ÄôAppendice B. Se un tale insieme di sequenze √® limitato a quelle di una certa lunghezza, ci√≤ viene denotato con un opportuno pedice, cosicch√© tutte le sequenze di byte di lunghezza 32 sono chiamate ùîπ32, e l‚Äôinsieme di tutti gli interi positivi minori di 2256 √® chiamato ‚Ñô256. Una definizione formale viene fornita nella sezione 4.3.
Le parentesi quadre sono usate per indicizzare e fornire un riferimento a componeneit individuali o sottosequenze di sequenze, ad esempio, Œºs[0] denoter√† il primo oggetto della stack di una macchina. Per le sottosequenze, vengono utilizzate delle ellissi per specificare il range desiderato, includendo i limiti estremi, per cui Œºm[0..31] denoter√† i primi32 oggetti memorizzati nella macchina.
In caso di uno stato globale œÉ, che costituisce una sequenza di accounts, a loro volta tuple, le parentesi quadre vengono utilizzate per specificare un account individuale.
Quando vengono considerate varianti di valori esistenti, vale la convenzione per cui, all‚Äôinterno dell‚Äôambito riconosciuto per definizione, se assumiamo che il valore di ‚Äòinput‚Äô, non modificato, sia indicato dalla variabile metasintattica BOH, allora il valore modificato ed utilizzabile, sar√† di conseguenza denotato come BOH‚Äô, ed i valori intermedi come BOH*, BOH**, eccetera. In situazioni eccezionali, al fine di migliorare la leggibilit√† e solo in assenza di ambiguit√† sul significato, saranno utilizzati pedici alfanumerici per i valori intermedi, specialmente quelli di particolare importanza.
Nell‚Äôuso di funzioni esistenti, data una funzione f, f* denoter√† una versione ad essa simile negli elementi della struttura funzionale, piuttosto che per quanto concerne le sequenze. Questo verr√† formalmente definito nella sezione 4.3.
Una serie di funzioni utili verranno definite a mano a mano. Una tra le pi√π comuni √® ‚Ñì, che valuta fino all‚Äôultimo elemento la sequenza data da:
(5)	‚Ñì(x) ‚â° x [||x|| ‚Äì 1]

IV.	Blocchi, Stati e Transazioni

Dopo aver introdotto i concetti di base dietro Ethereum, discutiamo il significato delle transazioni, dei blocchi e degli stati in maggior dettaglio.

IV.I Stato del mondo. Lo stato del mondo (stato), √® una funzione di mappatura tra indirizzi (identificatori a 160 bit) e stati dei conti (una struttura di dati serializzata come RLP, v. Appendice B). Sebbene non inclusa nella blockchain, si assume che l‚Äôimplementazione gestir√† tale funzione di mappatura in un Merkle-Patricia tree modificato (trie, v. Appendice D) [https://github.com/ethereum/wiki/wiki/Patricia-Tree]. Il trie richiede un semplice back end [http://it.wikipedia.org/wiki/Front-end_e_back-end] di un database che mantenga una mappatura dei bytearrays [http://en.wikipedia.org/wiki/Bit_array]; questo database sottostante prende il nome di database di stato. Esso possiede una serie di benefici; in prima istanza il root node [http://en.wikipedia.org/wiki/Tree_%28data_structure%29 e http://en.wikipedia.org/wiki/Merkle_tree] di questa struttura √® crittograficamente dipendente da tutti i dati interni e di conseguenza il suo hash pu√≤ essere utilizzato come identit√† sicura per l‚Äôintero stato del sistema. Inoltre, essendo una struttura di dati immutabile, consente ad un qualsiasi stato precedente (di cui sia noto il root hash) di essere richiamato con una semplice alterazione del root hash. Poich√© tutti i root hash della blockchain vengono immagazzinati, tutti gli stati passati sono banalmente revertibili.
Lo stato dell‚Äôaccount comprende i seguenti quattro campi:
Nonce: un valore scalare equivalente al numero di transazioni inviate da questo indirizzo o, nel caso di conti con codice associato, il numero di contratti creati da questo account. Per l‚Äôindirizzo del‚Äôaccount a nello stato œÉ, la notazione √® œÉ[a]n. 
Bilancio: un valore scalare pari al numero di Wei posseduti da questo indirizzo. Notazione: œÉ[a]b.
storageRoot: un hash a 256 bit presente nel root node di un Merkle Patricia tree, che codifica i contenuti presenti nello spazio di archiviazione dell‚Äôaccount (una funzione di mappatura tra valori interi a 256 bit), codificato all‚Äôinterno del trie come mapping (dall‚Äôhash Keccak a 256 bit) delle chiavi a numeri interi a 256 bit verso i valori interi RLP-codificati a 256 bit. Tale hash √® formalmente denotato da œÉ[a]s.
codeHash: l‚Äôhash del codice EVM riferito a questo account ‚Äì questo √® il codice che viene eseguito nel caso in cui questo indirizzo ricevesse un messaggio; rimane immutabile e dunque, a differenza di ogni altro campo, non pu√≤ essere modificato dopo la sua costituzione.Ognuno di questi frammenti di codice sono contenuti nel database di stato, sotto gli hash corrispondenti, per poter essere recuperabili in futuro. Questo hash viene denotato formalmente da œÉ[a]c, per cui il codice sar√† chiamato b, dato che KEC(b) = œÉ[a]c.  

Poich√© √® preferibile evitare di riferirsi al root hash del trie, quanto piuttosto all‚Äôinsieme di coppie chiavi/valori sottostanti, immagazzinate al suo interno, √® possibile fornire questa utile equivalenza:
(6)	TRIE(L*I(œÉ[a]s)) ‚â° œÉ[a]s
La funzione di collasso per l‚Äôinsieme delle coppie chiavi/valori nel trie, L*I, √® definita come una trasformazione della funzione di base LI, data da:
(7)	LI((k,v)) ‚â° (KEC(k), RLP(v))
Dove
(8)	k ‚àä ùîπ32 ‚àß v ‚àä ‚Ñô

